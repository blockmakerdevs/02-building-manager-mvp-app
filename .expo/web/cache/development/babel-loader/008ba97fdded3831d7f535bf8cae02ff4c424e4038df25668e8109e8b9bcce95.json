{"ast":null,"code":"import { interpolate } from 'react-native-reanimated';\nexport function getOffsetForValue(value, span) {\n  var minimumValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var maximumValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var range = maximumValue - minimumValue;\n  var relativeValue = minimumValue - value;\n  var v = minimumValue < 0 ? Math.abs(relativeValue) : value - minimumValue;\n  var ratio = v / range;\n  var x = ratio * span;\n  return x;\n}\nfunction countDecimals(value) {\n  'worklet';\n\n  if (Math.floor(value.valueOf()) === value.valueOf()) {\n    return 0;\n  }\n  return value.toString().split('.')[1].length || 0;\n}\nexport function getValueForOffset(offset, span) {\n  'worklet';\n\n  var minimum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var maximum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var step = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  if (span) {\n    var ratio = offset / span;\n    var range = maximum - minimum;\n    var val = ratio * range;\n    if (step > 0) {\n      var decimals = countDecimals(step);\n      val = Number((Math.round(ratio * range / step) * step).toFixed(decimals));\n    }\n    return Math.max(minimum, Math.min(maximum, minimum + val));\n  }\n  return 0;\n}\nfunction inRange(value, min, max) {\n  return value >= min && value <= max;\n}\nexport function validateValues(props) {\n  var useRange = props.useRange,\n    value = props.value,\n    _props$minimumValue = props.minimumValue,\n    minimumValue = _props$minimumValue === void 0 ? 0 : _props$minimumValue,\n    _props$maximumValue = props.maximumValue,\n    maximumValue = _props$maximumValue === void 0 ? 1 : _props$maximumValue,\n    initialMinimumValue = props.initialMinimumValue,\n    initialMaximumValue = props.initialMaximumValue;\n  if (minimumValue > maximumValue || useRange && initialMinimumValue && initialMaximumValue && initialMinimumValue > initialMaximumValue) {\n    console.error('Your passed values are invalid. Please check if minimum values are not higher than maximum values');\n  }\n  if (value !== undefined && minimumValue && maximumValue && !inRange(value, minimumValue, maximumValue)) {\n    console.error(`Your passed value (${value}) is invalid. \n      Please check that it is in range of the minimum (${minimumValue}) and maximum (${maximumValue}) values`);\n  }\n  if (useRange && initialMinimumValue && initialMaximumValue) {\n    if (!inRange(initialMinimumValue, minimumValue, maximumValue) || !inRange(initialMaximumValue, minimumValue, maximumValue)) {\n      console.error('Your passed values are invalid. Please check that they are in range of the minimum and maximum values');\n    }\n  }\n}\nexport function getStepInterpolated(trackWidth, minimumValue, maximumValue, stepXValue) {\n  'worklet';\n\n  var outputRange = [0, trackWidth];\n  var inputRange = minimumValue < 0 ? [Math.abs(maximumValue), Math.abs(minimumValue)] : [minimumValue, maximumValue];\n  return interpolate(stepXValue.value, inputRange, outputRange);\n}","map":{"version":3,"names":["interpolate","getOffsetForValue","value","span","minimumValue","arguments","length","undefined","maximumValue","range","relativeValue","v","Math","abs","ratio","x","countDecimals","floor","valueOf","toString","split","getValueForOffset","offset","minimum","maximum","step","val","decimals","Number","round","toFixed","max","min","inRange","validateValues","props","useRange","_props$minimumValue","_props$maximumValue","initialMinimumValue","initialMaximumValue","console","error","getStepInterpolated","trackWidth","stepXValue","outputRange","inputRange"],"sources":["/Users/mac/Repositories/BlockmakerIT/02-building-manager-mvp-app/node_modules/react-native-ui-lib/src/incubator/Slider/SliderPresenter.js"],"sourcesContent":["import { interpolate } from 'react-native-reanimated';\nexport function getOffsetForValue(value, span, minimumValue = 0, maximumValue = 1) {\n  const range = maximumValue - minimumValue;\n  const relativeValue = minimumValue - value;\n  const v = minimumValue < 0 ? Math.abs(relativeValue) : value - minimumValue; // for negative values\n  const ratio = v / range;\n  const x = ratio * span;\n  return x;\n}\nfunction countDecimals(value) {\n  'worklet';\n\n  if (Math.floor(value.valueOf()) === value.valueOf()) {\n    return 0;\n  }\n  return value.toString().split('.')[1].length || 0;\n}\nexport function getValueForOffset(offset, span, minimum = 0, maximum = 1, step = 0) {\n  'worklet';\n\n  if (span) {\n    const ratio = offset / span;\n    const range = maximum - minimum;\n    let val = ratio * range;\n    if (step > 0) {\n      const decimals = countDecimals(step);\n      val = Number((Math.round(ratio * range / step) * step).toFixed(decimals));\n    }\n    return Math.max(minimum, Math.min(maximum, minimum + val));\n  }\n  return 0;\n}\nfunction inRange(value, min, max) {\n  return value >= min && value <= max;\n}\nexport function validateValues(props) {\n  const {\n    useRange,\n    value,\n    minimumValue = 0,\n    maximumValue = 1,\n    initialMinimumValue,\n    initialMaximumValue\n  } = props;\n  if (minimumValue > maximumValue || useRange && initialMinimumValue && initialMaximumValue && initialMinimumValue > initialMaximumValue) {\n    console.error('Your passed values are invalid. Please check if minimum values are not higher than maximum values');\n  }\n  if (value !== undefined && minimumValue && maximumValue && !inRange(value, minimumValue, maximumValue)) {\n    console.error(`Your passed value (${value}) is invalid. \n      Please check that it is in range of the minimum (${minimumValue}) and maximum (${maximumValue}) values`);\n  }\n  if (useRange && initialMinimumValue && initialMaximumValue) {\n    if (!inRange(initialMinimumValue, minimumValue, maximumValue) || !inRange(initialMaximumValue, minimumValue, maximumValue)) {\n      console.error('Your passed values are invalid. Please check that they are in range of the minimum and maximum values');\n    }\n  }\n}\nexport function getStepInterpolated(trackWidth, minimumValue, maximumValue, stepXValue) {\n  'worklet';\n\n  const outputRange = [0, trackWidth];\n  const inputRange = minimumValue < 0 ? [Math.abs(maximumValue), Math.abs(minimumValue)] : [minimumValue, maximumValue];\n  return interpolate(stepXValue.value, inputRange, outputRange);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}