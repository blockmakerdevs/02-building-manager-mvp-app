{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport React, { useState, useCallback } from 'react';\nimport forwardRef from \"./forwardRef\";\nimport hoistStatics from 'hoist-non-react-statics';\nimport Constants from \"./Constants\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar DEFAULT_THRESHOLD = Constants.isAndroid ? 1 : 0;\nfunction withScrollReached(WrappedComponent) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var ScrollReachedDetector = function ScrollReachedDetector(props) {\n    var _useState = useState(true),\n      _useState2 = _slicedToArray(_useState, 2),\n      isScrollAtStart = _useState2[0],\n      setScrollAtStart = _useState2[1];\n    var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isScrollAtEnd = _useState4[0],\n      setScrollAtEnd = _useState4[1];\n    var onScroll = useCallback(function (event) {\n      var _event$nativeEvent = event.nativeEvent,\n        _event$nativeEvent$la = _event$nativeEvent.layoutMeasurement,\n        layoutWidth = _event$nativeEvent$la.width,\n        layoutHeight = _event$nativeEvent$la.height,\n        _event$nativeEvent$co = _event$nativeEvent.contentOffset,\n        offsetX = _event$nativeEvent$co.x,\n        offsetY = _event$nativeEvent$co.y,\n        _event$nativeEvent$co2 = _event$nativeEvent.contentSize,\n        contentWidth = _event$nativeEvent$co2.width,\n        contentHeight = _event$nativeEvent$co2.height;\n      var horizontal = options.horizontal;\n      var threshold = options.threshold || DEFAULT_THRESHOLD;\n      var layoutSize = horizontal ? layoutWidth : layoutHeight;\n      var offset = horizontal ? offsetX : offsetY;\n      var contentSize = horizontal ? contentWidth : contentHeight;\n      if (horizontal && Constants.isRTL && Constants.isAndroid) {\n        var scrollingWidth = Math.max(0, contentSize - layoutSize);\n        offset = scrollingWidth - offset;\n      }\n      var closeToStart = offset <= threshold;\n      if (closeToStart !== isScrollAtStart) {\n        setScrollAtStart(closeToStart);\n      }\n      var closeToEnd = layoutSize + offset >= contentSize - threshold;\n      if (closeToEnd !== isScrollAtEnd) {\n        setScrollAtEnd(closeToEnd);\n      }\n    }, [isScrollAtStart, isScrollAtEnd]);\n    return _jsx(WrappedComponent, _objectSpread(_objectSpread({}, props), {}, {\n      scrollReachedProps: {\n        onScroll: onScroll,\n        isScrollAtStart: isScrollAtStart,\n        isScrollAtEnd: isScrollAtEnd\n      },\n      ref: props.forwardedRef\n    }));\n  };\n  hoistStatics(ScrollReachedDetector, WrappedComponent);\n  ScrollReachedDetector.displayName = WrappedComponent.displayName;\n  ScrollReachedDetector.propTypes = WrappedComponent.propTypes;\n  ScrollReachedDetector.defaultProps = WrappedComponent.defaultProps;\n  return forwardRef(ScrollReachedDetector);\n}\nexport default withScrollReached;","map":{"version":3,"names":["React","useState","useCallback","forwardRef","hoistStatics","Constants","jsx","_jsx","DEFAULT_THRESHOLD","isAndroid","withScrollReached","WrappedComponent","options","arguments","length","undefined","ScrollReachedDetector","props","_useState","_useState2","_slicedToArray","isScrollAtStart","setScrollAtStart","_useState3","_useState4","isScrollAtEnd","setScrollAtEnd","onScroll","event","_event$nativeEvent","nativeEvent","_event$nativeEvent$la","layoutMeasurement","layoutWidth","width","layoutHeight","height","_event$nativeEvent$co","contentOffset","offsetX","x","offsetY","y","_event$nativeEvent$co2","contentSize","contentWidth","contentHeight","horizontal","threshold","layoutSize","offset","isRTL","scrollingWidth","Math","max","closeToStart","closeToEnd","_objectSpread","scrollReachedProps","ref","forwardedRef","displayName","propTypes","defaultProps"],"sources":["/Users/mac/Repositories/BlockmakerIT/02-building-manager-mvp-app/node_modules/react-native-ui-lib/src/commons/withScrollReached.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\nimport forwardRef from \"./forwardRef\";\nimport hoistStatics from 'hoist-non-react-statics';\nimport Constants from \"./Constants\";\nconst DEFAULT_THRESHOLD = Constants.isAndroid ? 1 : 0;\n\n/**\n * @description: Add scroll reached which notifies on reaching start \\ end of ScrollView \\ FlatList\n * @example: https://github.com/wix/react-native-ui-lib/blob/master/demo/src/screens/componentScreens/WithScrollReachedScreen.tsx\n * @notes: Send `props.scrollReachedProps.onScroll` to your onScroll and receive via props.scrollReachedProps.isScrollAtStart props.scrollReachedProps.isScrollAtEnd\n */\nfunction withScrollReached(WrappedComponent, options = {}) {\n  const ScrollReachedDetector = props => {\n    // The scroll starts at the start, from what I've tested this works fine\n    const [isScrollAtStart, setScrollAtStart] = useState(true);\n    const [isScrollAtEnd, setScrollAtEnd] = useState(false);\n    const onScroll = useCallback(event => {\n      const {\n        nativeEvent: {\n          layoutMeasurement: {\n            width: layoutWidth,\n            height: layoutHeight\n          },\n          contentOffset: {\n            x: offsetX,\n            y: offsetY\n          },\n          contentSize: {\n            width: contentWidth,\n            height: contentHeight\n          }\n        }\n      } = event;\n      const horizontal = options.horizontal;\n      const threshold = options.threshold || DEFAULT_THRESHOLD;\n      const layoutSize = horizontal ? layoutWidth : layoutHeight;\n      let offset = horizontal ? offsetX : offsetY;\n      const contentSize = horizontal ? contentWidth : contentHeight;\n      if (horizontal && Constants.isRTL && Constants.isAndroid) {\n        const scrollingWidth = Math.max(0, contentSize - layoutSize);\n        offset = scrollingWidth - offset;\n      }\n      const closeToStart = offset <= threshold;\n      if (closeToStart !== isScrollAtStart) {\n        setScrollAtStart(closeToStart);\n      }\n      const closeToEnd = layoutSize + offset >= contentSize - threshold;\n      if (closeToEnd !== isScrollAtEnd) {\n        setScrollAtEnd(closeToEnd);\n      }\n    }, [isScrollAtStart, isScrollAtEnd]);\n    return <WrappedComponent {...props} scrollReachedProps={{\n      onScroll,\n      isScrollAtStart,\n      isScrollAtEnd\n    }} ref={props.forwardedRef} />;\n  };\n  hoistStatics(ScrollReachedDetector, WrappedComponent);\n  ScrollReachedDetector.displayName = WrappedComponent.displayName;\n  //@ts-ignore\n  ScrollReachedDetector.propTypes = WrappedComponent.propTypes;\n  //@ts-ignore\n  ScrollReachedDetector.defaultProps = WrappedComponent.defaultProps;\n  return forwardRef(ScrollReachedDetector);\n}\nexport default withScrollReached;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}