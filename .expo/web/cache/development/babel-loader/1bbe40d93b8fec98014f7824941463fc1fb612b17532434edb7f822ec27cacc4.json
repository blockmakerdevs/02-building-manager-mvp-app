{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _times from \"lodash/times\";\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport useScrollTo from \"../useScrollTo\";\nimport { Constants } from \"../../commons/new\";\nexport var OffsetType = function (OffsetType) {\n  OffsetType[\"CENTER\"] = \"CENTER\";\n  OffsetType[\"DYNAMIC\"] = \"DYNAMIC\";\n  OffsetType[\"LEFT\"] = \"LEFT\";\n  OffsetType[\"RIGHT\"] = \"RIGHT\";\n  return OffsetType;\n}({});\nvar useScrollToItem = function useScrollToItem(props) {\n  var propsScrollViewRef = props.scrollViewRef,\n    itemsCount = props.itemsCount,\n    selectedIndex = props.selectedIndex,\n    _props$offsetType = props.offsetType,\n    offsetType = _props$offsetType === void 0 ? OffsetType.CENTER : _props$offsetType,\n    _props$addOffsetMargi = props.addOffsetMargin,\n    addOffsetMargin = _props$addOffsetMargi === void 0 ? true : _props$addOffsetMargi,\n    _props$outerSpacing = props.outerSpacing,\n    outerSpacing = _props$outerSpacing === void 0 ? 0 : _props$outerSpacing,\n    _props$innerSpacing = props.innerSpacing,\n    innerSpacing = _props$innerSpacing === void 0 ? 0 : _props$innerSpacing;\n  var itemsWidths = useRef(_times(itemsCount, function () {\n    return null;\n  }));\n  var currentIndex = useRef(selectedIndex || 0);\n  var _useState = useState({\n      CENTER: [],\n      LEFT: [],\n      RIGHT: []\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    offsets = _useState2[0],\n    setOffsets = _useState2[1];\n  var _useScrollTo = useScrollTo({\n      scrollViewRef: propsScrollViewRef\n    }),\n    scrollViewRef = _useScrollTo.scrollViewRef,\n    scrollTo = _useScrollTo.scrollTo,\n    onContentSizeChange = _useScrollTo.onContentSizeChange,\n    onLayout = _useScrollTo.onLayout;\n  var setSnapBreakpoints = useCallback(function (itemsWidths) {\n    if (_isEmpty(itemsWidths)) {\n      return;\n    }\n    var screenCenter = Constants.screenWidth / 2;\n    var index = 0;\n    var centeredOffsets = [];\n    var currentCenterOffset = outerSpacing;\n    var leftOffsets = [];\n    leftOffsets.push(outerSpacing - innerSpacing);\n    var rightOffsets = [];\n    rightOffsets.push(-Constants.screenWidth + itemsWidths[0] + outerSpacing + innerSpacing);\n    while (index < itemsCount) {\n      centeredOffsets[index] = currentCenterOffset - screenCenter + itemsWidths[index] / 2;\n      ++index;\n      currentCenterOffset += itemsWidths[index - 1] + innerSpacing;\n      leftOffsets[index] = leftOffsets[index - 1] + itemsWidths[index - 1] + innerSpacing;\n      rightOffsets[index] = rightOffsets[index - 1] + itemsWidths[index] + innerSpacing;\n    }\n    if (addOffsetMargin) {\n      index = 1;\n      while (index < itemsCount - 1) {\n        leftOffsets[index] -= itemsWidths[index - 1];\n        rightOffsets[index] += itemsWidths[index + 1] + innerSpacing;\n        ++index;\n      }\n    }\n    setOffsets({\n      CENTER: centeredOffsets,\n      LEFT: leftOffsets,\n      RIGHT: rightOffsets\n    });\n  }, [itemsCount, outerSpacing, innerSpacing, addOffsetMargin]);\n  var onItemLayout = useCallback(function (event, index) {\n    var width = event.nativeEvent.layout.width;\n    itemsWidths.current[index] = width;\n    if (!_includes(itemsWidths.current, null)) {\n      setSnapBreakpoints(itemsWidths.current);\n    }\n  }, [setSnapBreakpoints]);\n  var focusIndex = useCallback(function (index) {\n    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (index >= 0 && offsets.CENTER.length > index) {\n      if (offsetType !== OffsetType.DYNAMIC) {\n        scrollTo(offsets[offsetType][index], animated);\n      } else {\n        var movingLeft = index < currentIndex.current;\n        currentIndex.current = index;\n        scrollTo(movingLeft ? offsets[OffsetType.RIGHT][index] : offsets[OffsetType.LEFT][index], animated);\n      }\n    }\n  }, [offsets, offsetType, scrollTo]);\n  useEffect(function () {\n    if (!_isUndefined(selectedIndex)) {\n      focusIndex(selectedIndex);\n    }\n  }, [selectedIndex, focusIndex]);\n  return {\n    scrollViewRef: scrollViewRef,\n    onItemLayout: onItemLayout,\n    itemsWidths: offsets.CENTER.length > 0 ? itemsWidths.current : [],\n    focusIndex: focusIndex,\n    onContentSizeChange: onContentSizeChange,\n    onLayout: onLayout\n  };\n};\nuseScrollToItem.offsetType = OffsetType;\nexport default useScrollToItem;","map":{"version":3,"names":["_isUndefined","_includes","_isEmpty","_times","useState","useCallback","useEffect","useRef","useScrollTo","Constants","OffsetType","useScrollToItem","props","propsScrollViewRef","scrollViewRef","itemsCount","selectedIndex","_props$offsetType","offsetType","CENTER","_props$addOffsetMargi","addOffsetMargin","_props$outerSpacing","outerSpacing","_props$innerSpacing","innerSpacing","itemsWidths","currentIndex","_useState","LEFT","RIGHT","_useState2","_slicedToArray","offsets","setOffsets","_useScrollTo","scrollTo","onContentSizeChange","onLayout","setSnapBreakpoints","screenCenter","screenWidth","index","centeredOffsets","currentCenterOffset","leftOffsets","push","rightOffsets","onItemLayout","event","width","nativeEvent","layout","current","focusIndex","animated","arguments","length","undefined","DYNAMIC","movingLeft"],"sources":["/Users/mac/Repositories/BlockmakerIT/02-building-manager-mvp-app/node_modules/react-native-ui-lib/src/hooks/useScrollToItem/index.js"],"sourcesContent":["import _isUndefined from \"lodash/isUndefined\";\nimport _includes from \"lodash/includes\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _times from \"lodash/times\";\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport useScrollTo from \"../useScrollTo\";\nimport { Constants } from \"../../commons/new\";\nexport let OffsetType = /*#__PURE__*/function (OffsetType) {\n  OffsetType[\"CENTER\"] = \"CENTER\";\n  OffsetType[\"DYNAMIC\"] = \"DYNAMIC\";\n  OffsetType[\"LEFT\"] = \"LEFT\";\n  OffsetType[\"RIGHT\"] = \"RIGHT\";\n  return OffsetType;\n}({});\n\n// TODO: this is what I want, is there a better way to do it?\n\nconst useScrollToItem = props => {\n  const {\n    scrollViewRef: propsScrollViewRef,\n    itemsCount,\n    selectedIndex,\n    offsetType = OffsetType.CENTER,\n    addOffsetMargin = true,\n    outerSpacing = 0,\n    innerSpacing = 0\n  } = props;\n  const itemsWidths = useRef(_times(itemsCount, () => null));\n  const currentIndex = useRef(selectedIndex || 0);\n  const [offsets, setOffsets] = useState({\n    CENTER: [],\n    LEFT: [],\n    RIGHT: []\n  });\n  const {\n    scrollViewRef,\n    scrollTo,\n    onContentSizeChange,\n    onLayout\n  } = useScrollTo({\n    scrollViewRef: propsScrollViewRef\n  });\n\n  // TODO: reset?\n  //   useEffect(() => {\n  //     itemsWidths.current = _.times(itemsCount, () => null);\n  //   }, [itemsCount]);\n\n  // const contentWidth = _.sum(itemsWidths);\n  // TODO: const scrollEnabled = contentWidth.current > containerWidth;\n\n  const setSnapBreakpoints = useCallback(itemsWidths => {\n    if (_isEmpty(itemsWidths)) {\n      return;\n    }\n    const screenCenter = Constants.screenWidth / 2; // TODO: change to something more dynamic?\n    let index = 0;\n    const centeredOffsets = [];\n    let currentCenterOffset = outerSpacing;\n    const leftOffsets = [];\n    leftOffsets.push(outerSpacing - innerSpacing);\n    const rightOffsets = [];\n    rightOffsets.push(-Constants.screenWidth + itemsWidths[0] + outerSpacing + innerSpacing);\n    while (index < itemsCount) {\n      centeredOffsets[index] = currentCenterOffset - screenCenter + itemsWidths[index] / 2;\n      ++index;\n      currentCenterOffset += itemsWidths[index - 1] + innerSpacing;\n      leftOffsets[index] = leftOffsets[index - 1] + itemsWidths[index - 1] + innerSpacing;\n      rightOffsets[index] = rightOffsets[index - 1] + itemsWidths[index] + innerSpacing;\n    }\n    if (addOffsetMargin) {\n      index = 1;\n      while (index < itemsCount - 1) {\n        leftOffsets[index] -= itemsWidths[index - 1];\n        rightOffsets[index] += itemsWidths[index + 1] + innerSpacing;\n        ++index;\n      }\n    }\n    setOffsets({\n      CENTER: centeredOffsets,\n      LEFT: leftOffsets,\n      RIGHT: rightOffsets\n    }); // default for DYNAMIC is CENTER\n  }, [itemsCount, outerSpacing, innerSpacing, addOffsetMargin]);\n  const onItemLayout = useCallback((event, index) => {\n    const {\n      width\n    } = event.nativeEvent.layout;\n    itemsWidths.current[index] = width;\n    if (!_includes(itemsWidths.current, null)) {\n      setSnapBreakpoints(itemsWidths.current);\n    }\n  }, [setSnapBreakpoints]);\n  const focusIndex = useCallback((index, animated = true) => {\n    if (index >= 0 && offsets.CENTER.length > index) {\n      if (offsetType !== OffsetType.DYNAMIC) {\n        scrollTo(offsets[offsetType][index], animated);\n      } else {\n        const movingLeft = index < currentIndex.current;\n        currentIndex.current = index;\n        scrollTo(movingLeft ? offsets[OffsetType.RIGHT][index] : offsets[OffsetType.LEFT][index], animated);\n      }\n    }\n  }, [offsets, offsetType, scrollTo]);\n  useEffect(() => {\n    if (!_isUndefined(selectedIndex)) {\n      focusIndex(selectedIndex);\n    }\n  }, [selectedIndex, focusIndex]);\n  return {\n    scrollViewRef,\n    onItemLayout,\n    itemsWidths: offsets.CENTER.length > 0 ? itemsWidths.current : [],\n    focusIndex,\n    onContentSizeChange,\n    onLayout\n  };\n};\nuseScrollToItem.offsetType = OffsetType;\nexport default useScrollToItem;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}