{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport RNFS from \"./RNFSPackage\";\nvar DEFAULT_DYNAMIC_FONTS_FOLDER = '/dynamicFonts';\nvar DEFAULT_DOWNLOAD_ERROR_MESSAGE = 'An error occurred downloading the file:';\nvar FontDownloader = function () {\n  function FontDownloader(props) {\n    _classCallCheck(this, FontDownloader);\n    this.props = _objectSpread({\n      dynamicFontsFolder: DEFAULT_DYNAMIC_FONTS_FOLDER,\n      downloadErrorMessage: DEFAULT_DOWNLOAD_ERROR_MESSAGE\n    }, props);\n    if (!RNFS) {\n      throw new Error(`RNUILib FontDownloader requires installing \"react-native-fs\" dependency`);\n    }\n    this.fs = RNFS;\n  }\n  _createClass(FontDownloader, [{\n    key: \"log\",\n    value: function log(message) {\n      var debug = this.props.debug;\n      if (debug) {\n        for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          optionalParams[_key - 1] = arguments[_key];\n        }\n        console.log(message, optionalParams);\n      }\n    }\n  }, {\n    key: \"getPrivateFolder\",\n    value: function getPrivateFolder() {\n      var dynamicFontsFolder = this.props.dynamicFontsFolder;\n      return (Platform.OS === 'android' ? this.fs.ExternalDirectoryPath : this.fs.DocumentDirectoryPath) + dynamicFontsFolder;\n    }\n  }, {\n    key: \"getPrivateFilePath\",\n    value: function getPrivateFilePath(fileName) {\n      return this.getPrivateFolder() + '/' + fileName;\n    }\n  }, {\n    key: \"getFileName\",\n    value: function getFileName(fontName, fontExtension) {\n      return fontName + '.' + fontExtension;\n    }\n  }, {\n    key: \"_isFontDownloaded\",\n    value: function () {\n      var _isFontDownloaded2 = _asyncToGenerator(function* (fileName) {\n        var privateFilePath = this.getPrivateFilePath(fileName);\n        return yield this.fs.exists(privateFilePath);\n      });\n      function _isFontDownloaded(_x) {\n        return _isFontDownloaded2.apply(this, arguments);\n      }\n      return _isFontDownloaded;\n    }()\n  }, {\n    key: \"createPrivateFolderIfNeeded\",\n    value: function () {\n      var _createPrivateFolderIfNeeded = _asyncToGenerator(function* () {\n        var privateFolder = this.getPrivateFolder();\n        if (!(yield this.fs.exists(privateFolder))) {\n          yield this.fs.mkdir(privateFolder);\n        }\n      });\n      function createPrivateFolderIfNeeded() {\n        return _createPrivateFolderIfNeeded.apply(this, arguments);\n      }\n      return createPrivateFolderIfNeeded;\n    }()\n  }, {\n    key: \"getDownloadFontOptions\",\n    value: function getDownloadFontOptions(fontUri, downloadLocation, readTimeout) {\n      var platformSpecificOptions = Platform.OS === 'ios' ? {\n        background: false,\n        discretionary: true,\n        cacheable: false\n      } : {\n        connectionTimeout: readTimeout\n      };\n      return _objectSpread(_objectSpread({\n        fromUrl: fontUri,\n        toFile: downloadLocation\n      }, platformSpecificOptions), {}, {\n        fileCache: false,\n        readTimeout: readTimeout\n      });\n    }\n  }, {\n    key: \"downloadFont\",\n    value: (function () {\n      var _downloadFont = _asyncToGenerator(function* (fontUri, fontName, fontExtension, timeout) {\n        var downloadErrorMessage = this.props.downloadErrorMessage;\n        yield this.createPrivateFolderIfNeeded();\n        var fileName = this.getFileName(fontName, fontExtension);\n        var downloadLocation = this.getPrivateFilePath(fileName);\n        try {\n          this.log(fontName, 'Starting to download');\n          var result = yield this.fs.downloadFile(this.getDownloadFontOptions(fontUri, downloadLocation, timeout)).promise;\n          if (result.statusCode === 200) {\n            this.log(fontName, 'Finished downloading');\n            return downloadLocation;\n          } else {\n            this.log(fontName, 'Error downloading statusCode:', result.statusCode);\n            return Promise.reject({\n              source: 'uilib:FontDownloader:downloadFont',\n              message: `${downloadErrorMessage} fontName: ${fontName} statusCode: ${result.statusCode}`\n            });\n          }\n        } catch (error) {\n          this.log(fontName, 'Error downloading error:', error);\n          return Promise.reject({\n            source: 'uilib:FontDownloader:downloadFont',\n            message: `${downloadErrorMessage} fontName: ${fontName} error: ${JSON.stringify(error)}`\n          });\n        }\n      });\n      function downloadFont(_x2, _x3, _x4, _x5) {\n        return _downloadFont.apply(this, arguments);\n      }\n      return downloadFont;\n    }())\n  }, {\n    key: \"isFontDownloaded\",\n    value: (function () {\n      var _isFontDownloaded3 = _asyncToGenerator(function* (fontName, fontExtension) {\n        var fileName = this.getFileName(fontName, fontExtension);\n        return yield this._isFontDownloaded(fileName);\n      });\n      function isFontDownloaded(_x6, _x7) {\n        return _isFontDownloaded3.apply(this, arguments);\n      }\n      return isFontDownloaded;\n    }())\n  }, {\n    key: \"readFontFromDisk\",\n    value: function () {\n      var _readFontFromDisk = _asyncToGenerator(function* (fontName, fontExtension) {\n        var _this = this;\n        var base64FontString;\n        var fileName = this.getFileName(fontName, fontExtension);\n        var privateFilePath = this.getPrivateFilePath(fileName);\n        if (yield this.fs.exists(privateFilePath)) {\n          this.log(fontName, 'Starting to read from disk');\n          base64FontString = yield this.fs.readFile(privateFilePath, 'base64').catch(function (err) {\n            _this.log(fontName, 'Failed reading from disk:', err);\n          });\n          this.log(fontName, 'Finished reading from disk');\n        } else {\n          this.log(fontName, 'File does not exist (read)');\n        }\n        return base64FontString;\n      });\n      function readFontFromDisk(_x8, _x9) {\n        return _readFontFromDisk.apply(this, arguments);\n      }\n      return readFontFromDisk;\n    }()\n  }, {\n    key: \"deleteFontFromDisk\",\n    value: function () {\n      var _deleteFontFromDisk = _asyncToGenerator(function* (fontFullName) {\n        var _this2 = this;\n        var privateFilePath = this.getPrivateFilePath(fontFullName);\n        if (yield this.fs.exists(privateFilePath)) {\n          this.log(fontFullName, 'Starting to delete');\n          yield this.fs.unlink(privateFilePath).catch(function (err) {\n            _this2.log(fontFullName, 'Failed deleting:', err);\n          });\n          this.log(fontFullName, 'Finished deleting');\n        } else {\n          this.log(fontFullName, 'File does not exist (delete)');\n        }\n      });\n      function deleteFontFromDisk(_x10) {\n        return _deleteFontFromDisk.apply(this, arguments);\n      }\n      return deleteFontFromDisk;\n    }()\n  }]);\n  return FontDownloader;\n}();\nexport { FontDownloader as default };","map":{"version":3,"names":["RNFS","DEFAULT_DYNAMIC_FONTS_FOLDER","DEFAULT_DOWNLOAD_ERROR_MESSAGE","FontDownloader","props","_classCallCheck","_objectSpread","dynamicFontsFolder","downloadErrorMessage","Error","fs","_createClass","key","value","log","message","debug","_len","arguments","length","optionalParams","Array","_key","console","getPrivateFolder","Platform","OS","ExternalDirectoryPath","DocumentDirectoryPath","getPrivateFilePath","fileName","getFileName","fontName","fontExtension","_isFontDownloaded2","_asyncToGenerator","privateFilePath","exists","_isFontDownloaded","_x","apply","_createPrivateFolderIfNeeded","privateFolder","mkdir","createPrivateFolderIfNeeded","getDownloadFontOptions","fontUri","downloadLocation","readTimeout","platformSpecificOptions","background","discretionary","cacheable","connectionTimeout","fromUrl","toFile","fileCache","_downloadFont","timeout","result","downloadFile","promise","statusCode","Promise","reject","source","error","JSON","stringify","downloadFont","_x2","_x3","_x4","_x5","_isFontDownloaded3","isFontDownloaded","_x6","_x7","_readFontFromDisk","_this","base64FontString","readFile","catch","err","readFontFromDisk","_x8","_x9","_deleteFontFromDisk","fontFullName","_this2","unlink","deleteFontFromDisk","_x10","default"],"sources":["/Users/mac/Repositories/BlockmakerIT/02-building-manager-mvp-app/node_modules/react-native-ui-lib/lib/components/DynamicFonts/FontDownloader.js"],"sourcesContent":["import { Platform } from 'react-native';\nimport RNFS from \"./RNFSPackage\";\nconst DEFAULT_DYNAMIC_FONTS_FOLDER = '/dynamicFonts';\nconst DEFAULT_DOWNLOAD_ERROR_MESSAGE = 'An error occurred downloading the file:';\n// TODO: this can probably be a more general \"downloader\" if we so choose\nexport default class FontDownloader {\n  constructor(props) {\n    this.props = {\n      dynamicFontsFolder: DEFAULT_DYNAMIC_FONTS_FOLDER,\n      downloadErrorMessage: DEFAULT_DOWNLOAD_ERROR_MESSAGE,\n      ...props\n    };\n    if (!RNFS) {\n      throw new Error(`RNUILib FontDownloader requires installing \"react-native-fs\" dependency`);\n    }\n    this.fs = RNFS;\n  }\n  log(message, ...optionalParams) {\n    const {\n      debug\n    } = this.props;\n    if (debug) {\n      console.log(message, optionalParams);\n    }\n  }\n  getPrivateFolder() {\n    const {\n      dynamicFontsFolder\n    } = this.props;\n    return (Platform.OS === 'android' ? this.fs.ExternalDirectoryPath : this.fs.DocumentDirectoryPath) + dynamicFontsFolder;\n  }\n  getPrivateFilePath(fileName) {\n    return this.getPrivateFolder() + '/' + fileName;\n  }\n  getFileName(fontName, fontExtension) {\n    return fontName + '.' + fontExtension;\n  }\n  async _isFontDownloaded(fileName) {\n    const privateFilePath = this.getPrivateFilePath(fileName);\n    return await this.fs.exists(privateFilePath);\n  }\n  async createPrivateFolderIfNeeded() {\n    const privateFolder = this.getPrivateFolder();\n    if (!(await this.fs.exists(privateFolder))) {\n      await this.fs.mkdir(privateFolder);\n    }\n  }\n  getDownloadFontOptions(fontUri, downloadLocation, readTimeout) {\n    const platformSpecificOptions = Platform.OS === 'ios' ? {\n      background: false,\n      discretionary: true,\n      cacheable: false\n    } : {\n      connectionTimeout: readTimeout\n    };\n    return {\n      fromUrl: fontUri,\n      toFile: downloadLocation,\n      // TODO: It is possible to add a better progress, maybe for slower networks\n      // progress: ({bytesWritten, contentLength}: {bytesWritten: number; contentLength: number}) => {},\n      ...platformSpecificOptions,\n      fileCache: false,\n      readTimeout\n    };\n  }\n\n  /**\n   * Download the font\n   * @param fontUri the remote location of the font\n   * @param fontName the full name of the font\n   * @param fontExtension the extension of the font, i.e. '.ttf' or '.otf'\n   * @param timeout a timeout for the download to fail after\n   * @returns the full path of the download\n   */\n  async downloadFont(fontUri, fontName, fontExtension, timeout) {\n    const {\n      downloadErrorMessage\n    } = this.props;\n    await this.createPrivateFolderIfNeeded();\n    const fileName = this.getFileName(fontName, fontExtension);\n    const downloadLocation = this.getPrivateFilePath(fileName);\n    try {\n      this.log(fontName, 'Starting to download');\n      const result = await this.fs.downloadFile(this.getDownloadFontOptions(fontUri, downloadLocation, timeout)).promise;\n      if (result.statusCode === 200) {\n        this.log(fontName, 'Finished downloading');\n        return downloadLocation;\n      } else {\n        this.log(fontName, 'Error downloading statusCode:', result.statusCode);\n        return Promise.reject({\n          source: 'uilib:FontDownloader:downloadFont',\n          message: `${downloadErrorMessage} fontName: ${fontName} statusCode: ${result.statusCode}`\n        });\n      }\n    } catch (error) {\n      this.log(fontName, 'Error downloading error:', error);\n      return Promise.reject({\n        source: 'uilib:FontDownloader:downloadFont',\n        message: `${downloadErrorMessage} fontName: ${fontName} error: ${JSON.stringify(error)}`\n      });\n    }\n  }\n\n  /**\n   * Is the font cached (already downloaded)\n   * @param {*} fontName the full name of the font\n   * @param {*} fontExtension the extension of the font, i.e. '.ttf' or '.otf'\n   */\n  async isFontDownloaded(fontName, fontExtension) {\n    const fileName = this.getFileName(fontName, fontExtension);\n    return await this._isFontDownloaded(fileName);\n  }\n  async readFontFromDisk(fontName, fontExtension) {\n    let base64FontString;\n    const fileName = this.getFileName(fontName, fontExtension);\n    const privateFilePath = this.getPrivateFilePath(fileName);\n    if (await this.fs.exists(privateFilePath)) {\n      this.log(fontName, 'Starting to read from disk');\n      base64FontString = await this.fs.readFile(privateFilePath, 'base64').catch(err => {\n        this.log(fontName, 'Failed reading from disk:', err);\n      });\n      this.log(fontName, 'Finished reading from disk');\n    } else {\n      this.log(fontName, 'File does not exist (read)');\n    }\n    return base64FontString;\n  }\n  async deleteFontFromDisk(fontFullName) {\n    const privateFilePath = this.getPrivateFilePath(fontFullName);\n    if (await this.fs.exists(privateFilePath)) {\n      this.log(fontFullName, 'Starting to delete');\n      await this.fs.unlink(privateFilePath).catch(err => {\n        this.log(fontFullName, 'Failed deleting:', err);\n      });\n      this.log(fontFullName, 'Finished deleting');\n    } else {\n      this.log(fontFullName, 'File does not exist (delete)');\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}